<?xml version="1.0" encoding="UTF-8"?>
<hazelcast xsi:schemaLocation="http://www.hazelcast.com/schema/config hazelcast-config-3.12.xsd" xmlns="http://www.hazelcast.com/schema/config" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">


	<management-center enabled="true">http://localhost:9080/mancenter
	</management-center>

	<!-- Property settings -->
	<properties>
		<property name="hazelcast.logging.type">slf4j</property>
	</properties>

 	<group> 		
 	<name>${proven.hazelcast.group.name}</name>
<!--  	<password>${proven.hazelcast.group.password}</password> --> 
 	</group>

<!--      <group name="${proven.hazelcast.group.name}" password="${proven.hazelcast.group.password}"/> -->   

	<network>

		<port auto-increment="true" port-count="10">${proven.hazelcast.member.port}</port>

		<outbound-ports>
			<!-- Allowed port range when connecting to other nodes. 0 or * means use 
				system provided port. -->
			<ports>0</ports>
		</outbound-ports>

		<join>
			<multicast enabled="false"/>
			<tcp-ip enabled="true">
				<members>${proven.hazelcast.members}</members>
			</tcp-ip>
			<aws enabled="false"/>
		</join>
	</network>

	<!-- PER_MEMBER by default (i.e. random selection) -->
	<partition-group enabled="false"/>

	<!-- Domain message stream configuration  -->
	<map name="*.message">
		<time-to-live-seconds>0</time-to-live-seconds>
		<max-size policy="USED_HEAP_PERCENTAGE">60</max-size>
		<eviction-policy>LRU</eviction-policy>
		<async-backup-count>1</async-backup-count>
		<backup-count>0</backup-count>
	</map>
	
	<!--  Event journal configuration for domain message streams  -->
	<event-journal enabled="true">
		<mapName>*.message</mapName>
		<capacity>10000</capacity>
		<time-to-live-seconds>0</time-to-live-seconds>
	</event-journal>
	
	<!-- Deprecated.  Remove after refactor of DisclosureEntries -->
	<queue name="gov.pnnl.proven.external.disclosure">
		<max-size>10000</max-size>
		<async-backup-count>1</async-backup-count>
		<backup-count>0</backup-count>
		<empty-queue-ttl>-1</empty-queue-ttl>
	</queue>

	<!-- Disclosure queue -->
	<queue name="gov.pnnl.proven.component.exchange.${proven.lib.module.exchange.queue.disclosure.name}.*">
		<max-size>${proven.lib.module.exchange.queue.disclosure.max_size}</max-size>
		<async-backup-count>1</async-backup-count>
		<backup-count>0</backup-count>
		<empty-queue-ttl>-1</empty-queue-ttl>
	</queue>
	
	<!-- Exchange queue -->
	<queue name="gov.pnnl.proven.component.exchange.${proven.lib.module.exchange.queue.exchange.name}.*">
		<max-size>${proven.lib.module.exchange.queue.exchange.max_size}</max-size>
		<async-backup-count>1</async-backup-count>
		<backup-count>0</backup-count>
		<empty-queue-ttl>-1</empty-queue-ttl>
	</queue>
	
	<!-- Exchange buffer (Request & Disclosure)-->
	<ringbuffer name="gov.pnnl.proven.component.exchange.*">
		<capacity>1000</capacity>
		<backup-count>0</backup-count>
		<async-backup-count>1</async-backup-count>
		<time-to-live-seconds>0</time-to-live-seconds>
		<in-memory-format>BINARY</in-memory-format>
	</ringbuffer>

	<!-- Service buffer -->
	<ringbuffer name="gov.pnnl.proven.component.exchange.ServiceBuffer.*">
		<capacity>100</capacity>
		<backup-count>0</backup-count>
		<async-backup-count>1</async-backup-count>
		<time-to-live-seconds>0</time-to-live-seconds>
		<in-memory-format>BINARY</in-memory-format>
	</ringbuffer>

	<!-- Member registry  -->
	<set name="${proven.lib.module.registry.member.name}.*">
		<backup-count>0</backup-count>
		<async-backup-count>0</async-backup-count>
		<max-size>0</max-size>
		<item-listeners>
			<item-listener include-value="true">gov.pnnl.proven.cluster.lib.module.registry.ComponentRegistry</item-listener>
		</item-listeners>
	</set>

	<!-- Cluster registry  -->
	<map name="${proven.lib.module.registry.cluster.name}">
		<backup-count>1</backup-count>
		<async-backup-count>0</async-backup-count>
		<time-to-live-seconds>0</time-to-live-seconds>
		<in-memory-format>OBJECT</in-memory-format>
		<max-size>0</max-size>
	</map>

	<serialization>
		<data-serializable-factories>
			<data-serializable-factory factory-id="1">
				 gov.pnnl.proven.cluster.lib.disclosure.DisclosureIDSFactory
			</data-serializable-factory>
			<data-serializable-factory factory-id="2">
			    gov.pnnl.proven.cluster.lib.module.util.ModuleIDSFactory
			</data-serializable-factory>		
			<data-serializable-factory factory-id="3">
				gov.pnnl.proven.cluster.lib.pipeline.PipelineIDSFactory
			</data-serializable-factory>	
		</data-serializable-factories>
	</serialization>
	
<!-- 	<cp-subsystem> -->
<!--         <cp-member-count>3</cp-member-count> -->
<!--         <group-size>3</group-size> -->
<!--         <session-time-to-live-seconds>300</session-time-to-live-seconds> -->
<!--         <session-heartbeat-interval-seconds>5</session-heartbeat-interval-seconds> -->
<!--         <missing-cp-member-auto-removal-seconds>14400</missing-cp-member-auto-removal-seconds> -->
<!--         <fail-on-indeterminate-operation-state>false</fail-on-indeterminate-operation-state> -->
<!--         <persistence-enabled>true</persistence-enabled> -->
<!--         <base-dir>/custom-cp-dir</base-dir> -->
<!--     </cp-subsystem> -->

	<!-- ##################################################################################### -->

	<!-- DEFAULT HAZELCAST CONFIGURAIONS -->

	<executor-service name="default">
		<pool-size>16</pool-size>
		<!--Queue capacity. 0 means Integer.MAX_VALUE. -->
		<queue-capacity>0</queue-capacity>
	</executor-service>

	<map name="default">
		<!-- Data type that will be used for storing recordMap. Possible values: 
			BINARY (default): keys and values will be stored as binary data OBJECT : 
			values will be stored in their object forms NATIVE : values will be stored 
			in non-heap region of JVM -->
		<in-memory-format>BINARY</in-memory-format>

		<!-- Number of backups. If 1 is set as the backup-count for example, then 
			all entries of the map will be copied to another JVM for fail-safety. 0 means 
			no backup. -->
		<backup-count>1</backup-count>
		<!-- Number of async backups. 0 means no backup. -->
		<async-backup-count>0</async-backup-count>
		<!-- Maximum number of seconds for each entry to stay in the map. Entries 
			that are older than <time-to-live-seconds> and not updated for <time-to-live-seconds> 
			will get automatically evicted from the map. Any integer between 0 and Integer.MAX_VALUE. 
			0 means infinite. Default is 0. -->
		<time-to-live-seconds>0</time-to-live-seconds>
		<!-- Maximum number of seconds for each entry to stay idle in the map. 
			Entries that are idle(not touched) for more than <max-idle-seconds> will 
			get automatically evicted from the map. Entry is touched if get, put or containsKey 
			is called. Any integer between 0 and Integer.MAX_VALUE. 0 means infinite. 
			Default is 0. -->
		<max-idle-seconds>0</max-idle-seconds>
		<!-- Valid values are: NONE (no eviction), LRU (Least Recently Used), LFU 
			(Least Frequently Used). NONE is the default. -->
		<eviction-policy>LRU</eviction-policy>
		<!-- Maximum size of the map. When max size is reached, map is evicted 
			based on the policy defined. Any integer between 0 and Integer.MAX_VALUE. 
			0 means Integer.MAX_VALUE. Default is 0. -->
		<max-size policy="PER_NODE">0</max-size>
		<!-- `eviction-percentage` property is deprecated and will be ignored when 
			it is set. As of version 3.7, eviction mechanism changed. It uses a probabilistic 
			algorithm based on sampling. Please see documentation for further details -->
		<eviction-percentage>25</eviction-percentage>
		<!-- `min-eviction-check-millis` property is deprecated and will be ignored 
			when it is set. As of version 3.7, eviction mechanism changed. It uses a 
			probabilistic algorithm based on sampling. Please see documentation for further 
			details -->
		<min-eviction-check-millis>100</min-eviction-check-millis>
		<!-- While recovering from split-brain (network partitioning), map entries 
			in the small cluster will merge into the bigger cluster based on the policy 
			set here. When an entry merge into the cluster, there might an existing entry 
			with the same key already. Values of these entries might be different for 
			that same key. Which value should be set for the key? Conflict is resolved 
			by the policy set here. Default policy is PutIfAbsentMapMergePolicy There 
			are built-in merge policies such as com.hazelcast.map.merge.PassThroughMergePolicy; 
			entry will be overwritten if merging entry exists for the key. com.hazelcast.map.merge.PutIfAbsentMapMergePolicy 
			; entry will be added if the merging entry doesn't exist in the cluster. 
			com.hazelcast.map.merge.HigherHitsMapMergePolicy ; entry with the higher 
			hits wins. com.hazelcast.map.merge.LatestUpdateMapMergePolicy ; entry with 
			the latest update wins. -->
		<merge-policy>com.hazelcast.map.merge.PutIfAbsentMapMergePolicy</merge-policy>

		<!-- Control caching of de-serialized values. Caching makes query evaluation 
			faster, but it cost memory. Possible Values: NEVER: Never cache deserialized 
			object INDEX-ONLY: Caches values only when they are inserted into an index. 
			ALWAYS: Always cache deserialized values. -->
		<cache-deserialized-values>INDEX-ONLY</cache-deserialized-values>
		<statistics-enabled>true</statistics-enabled>

	</map>

	<queue name="default">
		<!-- Maximum size of the queue. When a JVM's local queue size reaches the 
			maximum, all put/offer operations will get blocked until the queue size of 
			the JVM goes down below the maximum. Any integer between 0 and Integer.MAX_VALUE. 
			0 means Integer.MAX_VALUE. Default is 0. -->
		<max-size>0</max-size>
		<!-- Number of backups. If 1 is set as the backup-count for example, then 
			all entries of the map will be copied to another JVM for fail-safety. 0 means 
			no backup. -->
		<backup-count>1</backup-count>

		<!-- Number of async backups. 0 means no backup. -->
		<async-backup-count>0</async-backup-count>

		<empty-queue-ttl>-1</empty-queue-ttl>
	</queue>

	<multimap name="default">
		<backup-count>1</backup-count>
		<value-collection-type>SET</value-collection-type>
	</multimap>

	<list name="default">
		<backup-count>1</backup-count>
	</list>

	<set name="default">
		<backup-count>1</backup-count>
	</set>

	<jobtracker name="default">
		<max-thread-size>0</max-thread-size>
		<!-- Queue size 0 means number of partitions * 2 -->
		<queue-size>0</queue-size>
		<retry-count>0</retry-count>
		<chunk-size>1000</chunk-size>
		<communicate-stats>true</communicate-stats>
		<topology-changed-strategy>CANCEL_RUNNING_OPERATION</topology-changed-strategy>
	</jobtracker>

	<semaphore name="default">
		<initial-permits>0</initial-permits>
		<backup-count>1</backup-count>
		<async-backup-count>0</async-backup-count>
	</semaphore>

	<reliable-topic name="default">
		<read-batch-size>10</read-batch-size>
		<topic-overload-policy>BLOCK</topic-overload-policy>
		<statistics-enabled>true</statistics-enabled>
	</reliable-topic>

	<ringbuffer name="default">
		<capacity>10000</capacity>
		<backup-count>1</backup-count>
		<async-backup-count>0</async-backup-count>
		<time-to-live-seconds>0</time-to-live-seconds>
		<in-memory-format>BINARY</in-memory-format>
	</ringbuffer>

	<services enable-defaults="true"/>

	<lite-member enabled="false"/>

</hazelcast>
